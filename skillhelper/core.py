"""Fill in a module description here"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['CAPABILITIES', 'parse_frontmatter', 'Skill', 'load_skill', 'discover_skills', 'SecurityPolicy', 'get_capabilities',
           'validate_capabilities', 'discover_from_paths', 'discover_from_entrypoints', 'discover_all', 'list_skills',
           'skill_tool_info']

# %% ../nbs/00_core.ipynb 13
from fastcore import *
import strictyaml
from fastcore.xtras import *
from fastcore.basics import first
from pathlib import Path
from dataclasses import dataclass
from typing import Optional
from fastcore.basics import patch
from safecmd import safe_run
import ast
import os

# %% ../nbs/00_core.ipynb 18
def parse_frontmatter(content:str):
    "Split YAML frontmatter and markdown body from SKILL.md content"
    if not content.startswith('---\n'):
        raise ValueError("SKILL.md must start with YAML frontmatter (---)")
    
    parts = content.split('---\n', 2)
    if len(parts) < 3:
        raise ValueError("SKILL.md frontmatter must be closed with ---")
    
    yaml_str = parts[1]
    body = parts[2].strip()
    
    try:
        metadata = strictyaml.load(yaml_str).data
    except Exception as e:
        raise ValueError(f"Invalid YAML frontmatter: {e}\nHint: Use block-style YAML (no flow-style arrays like [a,b,c])")
    
    return metadata, body

# %% ../nbs/00_core.ipynb 21
@dataclass
class Skill:
    "An Agent Skill loaded from a SKILL.md file"
    name: str
    description: str
    path: Path
    instructions: str
    license: Optional[str] = None
    compatibility: Optional[str] = None
    allowed_tools: Optional[str] = None
    metadata: Optional[dict] = None


# %% ../nbs/00_core.ipynb 22
def load_skill(skill_dir:Path):
    "Load a skill from a directory containing SKILL.md"
    skill_md = first(skill_dir/nm for nm in ('SKILL.md', 'skill.md') if (skill_dir/nm).exists())
    if not skill_md: raise FileNotFoundError(f"No SKILL.md found in {skill_dir}")
    
    content = skill_md.read_text()
    md, body = parse_frontmatter(content)
    
    return Skill(
        name=md['name'], 
        description=md['description'],
        path=skill_dir, 
        instructions=body,
        license=md.get('license'),
        compatibility=md.get('compatibility'),
        allowed_tools=md.get('allowed-tools'),  # Fix: use hyphen
        metadata=md.get('metadata')
    )

# %% ../nbs/00_core.ipynb 26
def discover_skills(skill_path:Path):
    "Find all skills in a directory by looking for SKILL.md files"
    skill_path = Path(skill_path)
    skills = []
    for skill_dir in skill_path.iterdir():
        if not skill_dir.is_dir(): continue
        if not any((skill_dir/nm).exists() for nm in ('SKILL.md', 'skill.md')): continue
        skills.append(load_skill(skill_dir))
    return skills

# %% ../nbs/00_core.ipynb 28
@patch
def load_reference(self:Skill, name:str):
    "Load a reference document from the references/ directory"
    ref_path = self.path/'references'/name
    if not ref_path.exists(): raise FileNotFoundError(f"Reference '{name}' not found in {self.path}")
    return ref_path.read_text()

# %% ../nbs/00_core.ipynb 30
@patch
def asset_path(self:Skill, name:str):
    "Get path to an asset file in the assets/ directory"
    asset = self.path/'assets'/name
    if not asset.exists(): raise FileNotFoundError(f"Asset '{name}' not found in {self.path}")
    return asset

# %% ../nbs/00_core.ipynb 38
@dataclass
class SecurityPolicy:
    allowed_tools: list[str]  # External bash commands
    allowed_capabilities: set[str] = None  # Python capabilities like 'filesystem', 'network'
    require_declaration: bool = True  # Skills must declare allowed-tools
    verify_scripts: bool = True  # Run static analysis before execution
    
    def __post_init__(self):
        if self.allowed_capabilities is None:
            self.allowed_capabilities = set()

# %% ../nbs/00_core.ipynb 39
def _build_allowlist(skill_tools:str, policy:SecurityPolicy=None):
    "Build allowlist from skill's allowed-tools and optional policy"
    if not skill_tools and not policy: return None
    
    skill_list = [t.strip() for t in skill_tools.split(',')] if skill_tools else []
    if not policy: return skill_list
    
    # Intersect skill tools with policy's allowed tools
    return [t for t in skill_list if t in policy.allowed_tools] if skill_list else policy.allowed_tools

# %% ../nbs/00_core.ipynb 40
@patch
def run_script(self:Skill, name:str, *args, policy:SecurityPolicy=None):
    "Execute a script from the scripts/ directory with optional security policy"
    script_path = self.path/'scripts'/name
    if not script_path.exists(): 
        raise FileNotFoundError(f"Script '{name}' not found in {self.path}/scripts")
    
    # Validate policy requirements
    if policy:
        if policy.require_declaration and not self.allowed_tools:
            raise ValueError(f"Skill '{self.name}' must declare allowed-tools")
        
        # Validate Python script capabilities
        if script_path.suffix == '.py' and policy.verify_scripts:
            required = get_capabilities(script_path)
            if not required <= policy.allowed_capabilities:
                disallowed = required - policy.allowed_capabilities
                raise ValueError(f"Script requires disallowed capabilities: {disallowed}")
    
    # Build allowlist and execute
    allowlist = _build_allowlist(self.allowed_tools, policy)
    argstr = ' '.join(str(a) for a in args)
    
    if script_path.suffix == '.py':
        return run_cmd('python', f"{script_path} {argstr}")
    
    # Bash script with safe_run if allowlist exists
    if allowlist:
        cmd = f"{script_path} {argstr}" if args else str(script_path)
        return safe_run(cmd, allowed=allowlist)
    
    return run_cmd('bash', f"{script_path} {argstr}")

# %% ../nbs/00_core.ipynb 42
CAPABILITIES = {
    'filesystem': {'open', 'pathlib.Path', 'os.path', 'os.remove', 'os.rename', 'shutil'},
    'subprocess': {'subprocess', 'os.system', 'os.popen', 'os.spawn'},
    'network': {'requests', 'urllib', 'socket', 'httpx', 'http.client'},
    'eval': {'eval', 'exec', '__import__', 'compile'},
}

# %% ../nbs/00_core.ipynb 43
def _extract_imports(tree):
    "Extract all imported modules from AST"
    imports = set()
    for node in ast.walk(tree):
        if isinstance(node, ast.Import):
            for alias in node.names:
                imports.add(alias.name.split('.')[0])  # Get root module
        elif isinstance(node, ast.ImportFrom):
            if node.module:
                imports.add(node.module.split('.')[0])
    return imports

# %% ../nbs/00_core.ipynb 44
def get_capabilities(script_path:Path):
    "Extract required capabilities from Python script based on imports"
    content = script_path.read_text()
    try: tree = ast.parse(content)
    except SyntaxError as e: raise ValueError(f"Invalid Python syntax in {script_path}: {e}")
    
    imports = _extract_imports(tree)
    required = set()
    
    for cap, modules in CAPABILITIES.items():
        if imports & modules:  # Intersection
            required.add(cap)
    
    return required

# %% ../nbs/00_core.ipynb 45
def validate_capabilities(skill:Skill, policy:SecurityPolicy):
    "Check if skill's Python scripts stay within policy's allowed capabilities"
    scripts_dir = skill.path/'scripts'
    if not scripts_dir.exists(): return True
    
    for script in scripts_dir.glob('*.py'):
        required = get_capabilities(script)
        if not required <= policy.allowed_capabilities:
            disallowed = required - policy.allowed_capabilities
            raise ValueError(f"Script {script.name} requires capabilities not in policy: {disallowed}")
    
    return True

# %% ../nbs/00_core.ipynb 51
@patch
def to_prompt(self:Skill):
    "Format skill instructions for injection into system prompt"
    prompt = f"# {self.name}\n\n{self.description}\n\n{self.instructions}"
    
    if self.compatibility:
        prompt += f"\n\n**Compatibility**: {self.compatibility}"
    
    if self.allowed_tools:
        prompt += f"\n\n**Required tools**: {self.allowed_tools}"
    
    return prompt

# %% ../nbs/00_core.ipynb 55
def discover_from_paths(paths):
    "Discover skills from a list of filesystem paths"
    skills = []
    for path in paths:
        path = Path(path)
        if path.exists():
            skills.extend(discover_skills(path))
    return skills

# %% ../nbs/00_core.ipynb 56
def discover_from_entrypoints():
    "Discover skills from pip-installed packages via entry points"
    try:
        from importlib.metadata import entry_points
    except ImportError:
        from importlib_metadata import entry_points  # Python < 3.8
    
    skills = []
    eps = entry_points()
    
    # Handle both dict and SelectableGroups return types
    group = eps.get('skillhelper.skills', []) if hasattr(eps, 'get') else eps.select(group='skillhelper.skills')
    
    for ep in group:
        try:
            get_skill_path = ep.load()
            skill_path = get_skill_path()
            skills.append(load_skill(skill_path))
        except Exception as e:
            print(f"Warning: Failed to load skill from entry point {ep.name}: {e}")
    
    return skills

# %% ../nbs/00_core.ipynb 57
def discover_all():
    "Discover skills from all sources: filesystem, entry points, and environment"
    skills = []
    
    # 1. Entry points (pip-installed packages)
    skills.extend(discover_from_entrypoints())
    
    # 2. Standard filesystem locations
    standard_paths = [
        Path.home() / '.skills',  # User skills
        Path('./skills'),          # Project-local skills
        Path('../skills'),         # nbdev development pattern
    ]
    skills.extend(discover_from_paths(standard_paths))
    
    # 3. Environment variable paths
    env_path = os.getenv('SOLVEIT_SKILLS_PATH')
    if env_path:
        env_paths = env_path.split(':')
        skills.extend(discover_from_paths(env_paths))
    
    # Deduplicate by name (first found wins)
    seen = set()
    unique = []
    for skill in skills:
        if skill.name not in seen:
            seen.add(skill.name)
            unique.append(skill)
    
    return unique

# %% ../nbs/00_core.ipynb 61
def list_skills(skills=None):
    "List available skills with name and description"
    if skills is None: skills = discover_all()
    
    result = []
    for skill in skills:
        result.append(f"**{skill.name}**: {skill.description}")
    
    return '\n'.join(result)

# %% ../nbs/00_core.ipynb 62
def skill_tool_info(skills=None):
    "List available skills for prompt injection"
    if skills is None: skills = discover_all()
    
    lines = ["**Available Skills:**"]
    for skill in skills:
        lines.append(f"- &`{skill.name}`: {skill.description}")
    
    return '\n'.join(lines)


# %% ../nbs/00_core.ipynb 69
@patch
def get_tools(self:Skill):
    "Return callable tool functions from the skill's tools.py"
    tools_py = self.path / 'tools.py'
    if not tools_py.exists(): return {}
    
    # Dynamically import the tools module
    import importlib.util
    spec = importlib.util.spec_from_file_location(f"{self.name}.tools", tools_py)
    if not spec or not spec.loader: return {}
    
    module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(module)
    
    # Extract functions with type annotations and docstrings
    tools = {}
    for name in dir(module):
        if name.startswith('_'): continue
        obj = getattr(module, name)
        if callable(obj) and hasattr(obj, '__annotations__') and obj.__doc__:
            tools[name] = obj
    
    return tools
