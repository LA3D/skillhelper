"""Solveit dialog integration for Agent Skills"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_skilleddialog.ipynb.

# %% auto 0
__all__ = ['SkilledDialog', 'use_skill', 'show_skills']

# %% ../nbs/02_skilleddialog.ipynb 3
from .core import *
from .core import SecurityPolicy, validate_capabilities

# %% ../nbs/02_skilleddialog.ipynb 4
from fastcore.basics import AttrDict, patch, first
from pathlib import Path
from dataclasses import dataclass
from typing import Optional, Callable
import sys

# %% ../nbs/02_skilleddialog.ipynb 5
# Optional imports - only available in solveit environment
try:
    from dialoghelper import add_msg, curr_dialog, mk_toollist, is_usable_tool
    IN_SOLVEIT = True
except ImportError:
    IN_SOLVEIT = False

# %% ../nbs/02_skilleddialog.ipynb 7
class SkilledDialog:
    "Extend solveit dialog with Agent Skills"
    def __init__(self, policy:SecurityPolicy=None):
        self.policy = policy
        self.active_skills = {}
        self._tool_namespace = {}  # Holds imported tool functions

# %% ../nbs/02_skilleddialog.ipynb 10
@patch
def list_skills(self:SkilledDialog):
    "List all available skills"
    return discover_all()

# %% ../nbs/02_skilleddialog.ipynb 13
@patch
def _skills_summary(self:SkilledDialog) -> str:
    "Return formatted skills metadata for dialog context"
    skills = discover_all()
    if not skills: return ""
    lines = ["## Available Skills", ""]
    for s in skills:
        lines.append(f"- **{s.name}**: {s.description}")
    lines.append("")
    lines.append("To activate a skill, use `sd.activate_skill('skill-name')`")
    return "\n".join(lines)

# %% ../nbs/02_skilleddialog.ipynb 16
@patch
def tool_declaration(self:SkilledDialog, skill_name:str=None) -> str:
    """Generate solveit backtick declaration for skill tools.
    
    If skill_name is provided, returns declaration for that skill.
    If None, returns declaration for all active skill tools.
    """
    if skill_name:
        skill = self.active_skills.get(skill_name)
        if not skill: return ""
        tools = list(skill.get_tools().keys())
    else:
        tools = list(self._tool_namespace.keys())
    
    if not tools: return ""
    if len(tools) == 1:
        return f"& `{tools[0]}`"
    return f"& `[{', '.join(tools)}]`"

# %% ../nbs/02_skilleddialog.ipynb 18
@patch
def activate_skill(self:SkilledDialog, name:str, inject_msg:bool=True) -> AttrDict:
    """Activate a skill for use in solveit dialog.
    
    Args:
        name: Name of the skill to activate
        inject_msg: If True and in solveit, inject instructions via add_msg()
    
    Returns:
        AttrDict with success, skill, tools, declaration, and error fields
    """
    # Find the skill
    skill = first(s for s in discover_all() if s.name == name)
    if not skill:
        return AttrDict(success=False, skill=None, tools=[], declaration="", 
                       error=f"Skill '{name}' not found")
    
    # Security validation
    if self.policy:
        try:
            validate_capabilities(skill, self.policy)
        except ValueError as e:
            return AttrDict(success=False, skill=None, tools=[], declaration="",
                           error=str(e))
    
    # Store active skill
    self.active_skills[name] = skill
    
    # Import tools into namespace
    skill_tools = skill.get_tools()
    for tool_name, tool_func in skill_tools.items():
        self._tool_namespace[tool_name] = tool_func
    
    # Generate tool declaration
    declaration = self.tool_declaration(name)
    
    # Inject instructions into dialog if in solveit
    if inject_msg and IN_SOLVEIT:
        msg_content = f"[Skill activated: {name}]\n\n{skill.instructions}\n\n"
        msg_content += f"**Tools available:** {declaration}"
        add_msg(msg_content, msg_type='note')
    
    return AttrDict(
        success=True,
        skill=skill,
        tools=list(skill_tools.values()),
        declaration=declaration,
        error=None
    )

# %% ../nbs/02_skilleddialog.ipynb 22
@patch
def get_tools(self:SkilledDialog) -> dict:
    """Get all active skill tools for namespace injection.
    
    Usage in solveit:
        globals().update(sd.get_tools())
    """
    return self._tool_namespace.copy()

# %% ../nbs/02_skilleddialog.ipynb 25
@patch
def deactivate_skill(self:SkilledDialog, name:str) -> bool:
    """Deactivate a skill and remove its tools from namespace."""
    if name not in self.active_skills:
        return False
    
    skill = self.active_skills.pop(name)
    # Remove tools from namespace
    for tool_name in skill.get_tools().keys():
        self._tool_namespace.pop(tool_name, None)
    
    return True

# %% ../nbs/02_skilleddialog.ipynb 28
def use_skill(name:str, policy:SecurityPolicy=None, inject_msg:bool=True) -> AttrDict:
    """Quick skill activation for solveit.
    
    Creates a SkilledDialog, activates the skill, and returns result.
    
    Usage in solveit:
        result = use_skill('code-reviewer')
        globals().update(result.tools_dict)
        # Then include in prompt: & `[check_style, count_lines]`
    
    Args:
        name: Skill name to activate
        policy: Optional security policy
        inject_msg: If True, inject instructions into dialog
    
    Returns:
        AttrDict with success, skill, tools, tools_dict, declaration, error
    """
    sd = SkilledDialog(policy)
    result = sd.activate_skill(name, inject_msg=inject_msg)
    result.tools_dict = sd.get_tools()
    result.skilled_dialog = sd
    return result

# %% ../nbs/02_skilleddialog.ipynb 32
def show_skills():
    """Display available skills in formatted output."""
    skills = discover_all()
    if not skills:
        print("No skills found.")
        return
    
    print("Available Skills:\n")
    for s in skills:
        print(f"  {s.name}")
        print(f"    {s.description}")
        tools = list(s.get_tools().keys())
        if tools:
            print(f"    Tools: {', '.join(tools)}")
        print()
